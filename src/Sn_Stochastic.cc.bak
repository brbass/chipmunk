#include <vector>
#include <cmath>
#include <iostream>
#include <string>
#include <random>
#include <algorithm>

#include "Sn_Transport.hh"
#include "Sn_Stochastic.hh"

Sn_Stochastic::
Sn_Stochastic(vector<double> &internal_source,
              vector<double> &boundary_sources,
              vector<string> &boundary_conditions,
              vector<double> &cell_length,
              vector<double> &sigma_t,
              vector<double> &sigma_s,
              vector<double> &nu_sigma_f,
              vector<double> &chi,
              vector<double> &ordinates,
              vector<double> &weights,
              vector<double> &chord_length,
              unsigned &number_of_cells,
              unsigned &number_of_groups,
              unsigned &number_of_ordinates,
              unsigned &number_of_materials,
              unsigned &max_iterations,
              double &tolerance)
:
    Sn_Transport(internal_source,
                 boundary_sources,
                 boundary_conditions,
                 cell_length,
                 sigma_t,
                 sigma_s,
                 nu_sigma_f,
                 chi,
                 ordinates,
                 weights,
                 number_of_cells,
                 number_of_groups,
                 number_of_ordinates,
                 max_iterations,
                 tolerance),
    chord_length(chord_length),
    number_of_materials(number_of_materials)
{
    // run checks here?

    // calculate transition probability from chord length
    transition_probability.resize(number_of_materials, 0.0);

    double denominator = 0;
    for (unsigned m = 0; m < number_of_materials; ++m)
    {
        denominator += chord_length[m];
    }

    for (unsigned m = 0; m < number_of_materials; ++m)
    {
        transition_probability[m] = chord_length[m] / denominator;
    }
    
}

void Sn_Stochastic::
run_constant_mesh(vector<double> &psi_edge,
                  vector<double> &psi_edge_total)
{
    using namespace std;
        
    // temporary variables
    vector<double> phi (number_of_cells * number_of_groups * number_of_nodes, 0); // average scalar flux
    vector<double> phi_old (number_of_cells * number_of_groups * number_of_nodes, 0); // average scalar flux from previous iteration
    vector<double> q (number_of_materials * number_of_cells * number_of_groups * number_of_nodes, 0); // total source, including fission and scattering
    vector<double> psi_nodal (number_of_materials * number_of_cells * number_of_groups * number_of_ordinates * number_of_nodes, 0); // angular flux, left and right
    vector<double> psi_boundary_sources (number_of_groups * number_of_ordinates, 0);
    vector<double> error_phi(number_of_cells * number_of_groups * number_of_nodes, 1);
    vector<double> error_phi_old(number_of_cells * number_of_groups * number_of_nodes, 1);
    
    // make initial guess for psi into a nodal quantity
    for (unsigned m = 0; m < number_of_materials; ++m)
    {
        for (unsigned i = 0; i < number_of_cells; ++i)
        {
            for (unsigned o = 0; o < number_of_ordinates; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    for (unsigned n = 0; n < number_of_nodes; ++n)
                    {
                        unsigned  k1 = n + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
                        unsigned  k2 = g + number_of_groups * (o + number_of_ordinates * ((i+n) + (number_of_cells + 1) * m));
				
                        psi_nodal[k1] = psi_edge[k2];
                    }
                }
            }
        }
    }
    // begin iterations
    for (unsigned it = 0; it < max_iterations; ++it)
    {
        // calculate the source
        for (unsigned m = 0; m < number_of_materials; ++m)
        {
            for (unsigned i = 0; i < number_of_cells; ++i)
            {
                for (unsigned n = 0; n < number_of_nodes; ++n)
                {
                    for (unsigned g = 0; g < number_of_groups; ++g)
                    {
                        double sum = 0;
                        for (unsigned g2 = 0; g2 < number_of_groups; ++g2)
                        {
                            unsigned  k1 = g2 + number_of_groups * (i + number_of_cells * m);
                            unsigned  k2 = g2 + number_of_groups * (g + number_of_groups * (i + number_of_cells * m));
                            unsigned  k3 = n + number_of_nodes * (g2 + number_of_groups * i);
			    unsigned  k4 = g + number_of_groups * (i + number_of_cells * m);
                            
                            sum += (chi[k4] * nu_sigma_f[k1] + sigma_s[k2]) * phi[k3];
                        }
                        unsigned  k1 = n + number_of_nodes * (g + number_of_groups * (i + number_of_cells * m));
                        unsigned  k2 = g + number_of_groups * i;
			
                        q[k1] = (internal_source[k2] + sum) / 2 * transition_probability[m];
                    }
                }
            }
        }


        // boundary condition, x=0
        if (boundary_conditions[0] == "reflected")
        {
            for (unsigned o = 0; o < number_of_ordinates / 2; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    double sum = 0;
                    for (unsigned m = 0; m < number_of_materials; ++m)
                    {
                        unsigned k1 = 0 + number_of_nodes * (g + number_of_groups * ((number_of_ordinates - 1 - o) + number_of_ordinates * (0 + number_of_cells * m)));

                        sum += psi_nodal[k1];
                    }
                    unsigned k1 = g + number_of_groups * o;

                    psi_boundary_sources[k1] = sum;
                }
            }
        }
        else if (boundary_conditions[0] == "vacuum")
        {
            for (unsigned o = 0; o < number_of_ordinates / 2; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    unsigned k1 = g + number_of_groups * o;
                                        
                    psi_boundary_sources[k1] = 0;
                }
            }
        }
        
        // sweep first cell
        for (unsigned  m = 0; m < number_of_materials; ++m)
        {
            for (unsigned  o = 0; o < number_of_ordinates / 2; ++o)
            {
                for (unsigned  g = 0; g < number_of_groups; ++g)
                {
                    unsigned  i = 0;
                    unsigned  k1 = g + number_of_groups * (i + number_of_cells * m);
                    unsigned  k2 = g + number_of_groups * o;
                    unsigned  k3 = number_of_nodes * (g + number_of_groups * (i + number_of_cells * m));
                    unsigned  k4 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));

                    double a1 = ordinates[o] / 2 + sigma_t[k1] * cell_length[i] / 2;
                    double a2 = ordinates[o] / 2;
                    double a3 = -ordinates[o] / 2;
                    double a4 = ordinates[o] / 2 + sigma_t[k1] * cell_length[i] / 2;
                    double s1 = cell_length[i] * (q[k3] / 2) + ordinates[o] *  (boundary_sources[k2] + psi_boundary_sources[k2]) * transition_probability[m];
                    double s2 = cell_length[i] * (q[k3+1] / 2);
		
                    psi_nodal[k4] = (a4 * s1 - a2 * s2) / (a1 * a4 - a2 * a3);
                    psi_nodal[k4+1] = (a3 * s1 - a1 * s2) / (a2 * a3 - a1 * a4);
                }
            }
        }

        // sweep right over cells
        for (unsigned  m = 0; m < number_of_materials; ++m)
        {
            for (unsigned  i = 1; i < number_of_cells; ++i)
            {
                for (unsigned  o = 0; o < number_of_ordinates / 2; ++o)
                {
                    for (unsigned  g = 0; g < number_of_groups; ++g)
                    {
                        unsigned  k1 = g + number_of_groups * (i + number_of_cells * m);
                        unsigned  k3 = number_of_nodes * (g + number_of_groups * (i + number_of_cells * m));
                        unsigned  k4 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));

                        double stochastic_edge_source = 0; // part of previous cell's flux to be sweeped in current material
		    
                        for (unsigned  m1 = 0; m1 < number_of_materials; ++m1)
                        {
                            unsigned  k5 = 1 + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * ((i-1) + number_of_cells * m1)));
			
                            stochastic_edge_source += psi_nodal[k5] * transition_probability[m];
                        }
		    
                        double a1 = ordinates[o] / 2 + sigma_t[k1] * cell_length[i] / 2;
                        double a2 = ordinates[o] / 2;
                        double a3 = -ordinates[o] / 2;
                        double a4 = ordinates[o] / 2 + sigma_t[k1] * cell_length[i] / 2;
                        double s1 = cell_length[i] * (q[k3] / 2) + ordinates[o] * stochastic_edge_source;
                        double s2 = cell_length[i] * (q[k3+1] / 2);
				
                        psi_nodal[k4] = (a4 * s1 - a2 * s2) / (a1 * a4 - a2 * a3);
                        psi_nodal[k4+1] = (a3 * s1 - a1 * s2) / (a2 * a3 - a1 * a4);
                    }
                }
            }
        }

        // boundary condition, x=X
        if (boundary_conditions[1] == "reflected")
        {
            for (unsigned o = number_of_ordinates / 2; o < number_of_ordinates; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {

                    double sum = 0;
                    for (unsigned m = 0; m < number_of_materials; ++m)
                    {
                        unsigned k1 = 1 + number_of_nodes * (g + number_of_groups * ((number_of_ordinates - 1 - o) + number_of_ordinates * ((number_of_cells - 1) + number_of_cells * m)));

                        sum += psi_nodal[k1];
                    }
                    unsigned k1 = g + number_of_groups * o;

                    psi_boundary_sources[k1] = sum;
                }
            }
        }
        else if (boundary_conditions[1] == "vacuum")
        {
            for (unsigned o = number_of_ordinates / 2; o < number_of_ordinates; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    unsigned k1 = g + number_of_groups * o;
                                        
                    psi_boundary_sources[k1] = 0;
                }
            }
        }
   
        // sweep final cell
        for (unsigned  m = 0; m < number_of_materials; ++m)
        {
            for (unsigned  o = number_of_ordinates / 2; o < number_of_ordinates; ++o)
            {
                for (unsigned  g = 0; g < number_of_groups; ++g)
                {
                    unsigned  i = number_of_cells - 1;
                    unsigned  k1 = g + number_of_groups * (i + number_of_cells * m);
                    unsigned  k2 = g + number_of_groups * o;
                    unsigned  k3 = number_of_nodes * (g + number_of_groups * (i + number_of_cells * m));
                    unsigned  k4 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));

                    double a1 = -ordinates[o] / 2 + sigma_t[k1] * cell_length[i] / 2;
                    double a2 = ordinates[o] / 2;
                    double a3 = -ordinates[o] / 2;
                    double a4 = -ordinates[o] / 2 + sigma_t[k1] * cell_length[i] / 2;
                    double s1 = cell_length[i] * (q[k3] / 2);
                    double s2 = cell_length[i] * (q[k3+1] / 2) - ordinates[o] * (boundary_sources[k2] + psi_boundary_sources[k2]) * transition_probability[m];
				
                    psi_nodal[k4] = (a4 * s1 - a2 * s2) / (a1 * a4 - a2 * a3);
                    psi_nodal[k4+1] = (a3 * s1 - a1 * s2) / (a2 * a3 - a1 * a4);		
                }
            }
        }
        
        // sweep left over cells
        for (unsigned  m = 0; m < number_of_materials; ++m)
        {
            for (int  i = number_of_cells - 2; i >= 0; --i)
            {
                for (unsigned  o = number_of_ordinates / 2; o < number_of_ordinates; ++o)
                {
                    for (unsigned  g = 0; g < number_of_groups; ++g)
                    {
                        unsigned  k1 = g + number_of_groups * (i + number_of_cells * m);
                        unsigned  k3 = number_of_nodes * (g + number_of_groups * (i + number_of_cells * m));
                        unsigned  k4 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));

                        double stochastic_edge_source = 0; // part of previous cell's flux to be sweeped in current material
		    
                        for (unsigned  m1 = 0; m1 < number_of_materials; ++m1)
                        {
                            unsigned  k5 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * ((i+1) + number_of_cells * m1)));
			
                            stochastic_edge_source += psi_nodal[k5] * transition_probability[m];
                        }
		    
                        double a1 = -ordinates[o] / 2 + sigma_t[k1] * cell_length[i] / 2;
                        double a2 = ordinates[o] / 2;
                        double a3 = -ordinates[o] / 2;
                        double a4 = -ordinates[o] / 2 + sigma_t[k1] * cell_length[i] / 2;
                        double s1 = cell_length[i] * (q[k3] / 2);
                        double s2 = cell_length[i] * (q[k3+1] / 2) - ordinates[o] * stochastic_edge_source;
				
                        psi_nodal[k4] = (a4 * s1 - a2 * s2) / (a1 * a4 - a2 * a3);
                        psi_nodal[k4+1] = (a3 * s1 - a1 * s2) / (a2 * a3 - a1 * a4);		
                    }
                }
            }
        }

        // calculate new scalar flux
        phi_old = phi;
        for (unsigned  i = 0; i < number_of_cells; ++i)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                for (unsigned  n = 0; n < number_of_nodes; ++n)
                {
                    double sum = 0;
		
                    for (unsigned  o = 0; o < number_of_ordinates; ++o)
                    {
                        for (unsigned  m = 0; m < number_of_materials; ++m)
                        {
                            unsigned  k1 = n + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
			
                            sum += weights[o] * psi_nodal[k1];
                        }
                    }
                    unsigned  k1 = n + number_of_nodes * (g + number_of_groups * i);
		
                    phi[k1] = sum;
                }
            }
        }
        // check for convergence
        bool converged = true;
        error_phi_old = error_phi;
    
        for (unsigned  i = 0; i < number_of_cells; ++i)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                for (unsigned  n = 0; n < number_of_nodes; ++n)
                {
                    unsigned  k1 = n + number_of_nodes * (g + number_of_groups * i);
                    error_phi[k1] = abs(phi[k1] - phi_old[k1]) / phi[k1];
                    if (error_phi[k1] > tolerance * (1 - error_phi[k1] / error_phi_old[k1]))
                    {
                        converged = false;
                        break;
                    }
                }
                if (!converged)
                {
                    break;
                }
            }
            if (!converged)
            {
                break;
            }
        }
        if (converged)
        {
            // cout << "Iterations to converge: " << it << endl;
            break;
        }
        else if (it==max_iterations-1)
        {
            // cout << "Did not converge" << endl;
        }
    }

    for (unsigned  m = 0; m < number_of_materials; ++m)
    {
        //assign left edge flux
        for (unsigned  o = 0; o < number_of_ordinates; ++o)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                unsigned  i = 0;
                unsigned  k1 = g + number_of_groups * (o + number_of_ordinates * (i + (number_of_cells + 1) * m));
                unsigned  k2 = number_of_nodes * (g + number_of_groups * (o +number_of_ordinates * (i + number_of_cells * m))); // n=0
		
                psi_edge[k1] = psi_nodal[k2];
            }
        }

        // calculate edge fluxes
        for (unsigned  i = 1; i < number_of_cells; ++i)
        {
            for (unsigned  o = 0; o < number_of_ordinates; ++o)
            {
                for (unsigned  g = 0; g < number_of_groups; ++g)
                {
                    unsigned  k1 = g + number_of_groups * (o +number_of_ordinates * (i + (number_of_cells + 1) * m));
                    unsigned  k2 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
                    unsigned  k3 = 1 + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * ((i - 1) + number_of_cells * m))); // n=1
	    
                    psi_edge[k1] = (psi_nodal[k2] + psi_nodal[k3]) / 2; 
                }
            }
        }

        // assign right edge flux
        for (unsigned  o = 0; o < number_of_ordinates; ++o)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                unsigned  i = number_of_cells;
                unsigned  k1 = g + number_of_groups * (o + number_of_ordinates * (i + (number_of_cells + 1) * m));
                unsigned  k2 = 1 + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * ((i - 1) + number_of_cells * m)));
	    
                psi_edge[k1] = psi_nodal[k2];
            }
        }
    }

    // assign total edge flux
    for (unsigned  i = 0; i < number_of_cells + 1; ++i)
    {
        for (unsigned  o = 0; o < number_of_ordinates; ++o)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                double sum = 0;
	    
                for (unsigned  m = 0; m < number_of_materials; ++m)
                {
                    unsigned  k1 = g + number_of_groups * (o + number_of_ordinates * (i + (number_of_cells + 1) * m));

                    sum += psi_edge[k1];
                }
	    
                unsigned  k1 = g + number_of_groups * (o + number_of_ordinates * i);
	    
                psi_edge_total[k1] = sum;
            }
        }
    }
}

void Sn_Stochastic::
run_percentage_benchmark(vector<double> &psi_edge_benchmark,
                         vector<double> &psi_edge_benchmark_total,
                         unsigned &number_of_benchmarks)
{
    vector<double> psi_edge_temp((number_of_cells + 1) * number_of_groups * number_of_ordinates, 0);

    vector<unsigned> number_of_material_cells(number_of_materials, 0.0);
    vector<double> sigma_t_percentage(number_of_cells * number_of_groups, 0.0);
    vector<double> sigma_s_percentage(number_of_cells * number_of_groups * number_of_groups, 0.0);
    vector<double> nu_sigma_f_percentage(number_of_cells * number_of_groups, 0.0);
    vector<double> chi_percentage(number_of_cells * number_of_groups, 0.0);

    unsigned sum = 0;
    for (unsigned m = 0; m < number_of_materials; ++m)
    {
        number_of_material_cells[m] = transition_probability[m] * number_of_cells;
        sum += number_of_material_cells[m];
    }
    
    number_of_material_cells[0] += number_of_cells - sum;
    
    vector<unsigned> cell_material(number_of_cells, 0);
    unsigned current_cell = 0;

    for (unsigned m = 0; m < number_of_materials; ++m)
    {
        unsigned start_cell = current_cell;
        for (unsigned i = start_cell; i < start_cell + number_of_material_cells[m]; ++i)
        {
            cell_material[i] = m;
            current_cell += 1;
        }
    }

    for (unsigned i = 0; i < number_of_cells; ++i)
    {
        for (unsigned o = 0; o < number_of_ordinates; ++o)
        {
            for (unsigned g = 0; g < number_of_groups; ++g)
            {
                unsigned k1 = g + number_of_groups * i;
                unsigned k2 = g + number_of_groups * (i + number_of_cells * cell_material[i]);
                    
                sigma_t_percentage[k1] = sigma_t[k2];
                nu_sigma_f_percentage[k1] = nu_sigma_f[k2];
                chi_percentage[k1] = chi[k2];

                for (unsigned g1 = 0; g1 < number_of_groups; ++g1)
                {
                    unsigned k3 = g + number_of_groups * (g1 + number_of_groups * i);
                    unsigned k4 = g + number_of_groups * (g1 + number_of_groups * (i + number_of_cells * cell_material[i]));;
                        
                    sigma_s_percentage[k3] = sigma_s[k4];
                }
            }
        }
    }

    sigma_t_percentage.swap(sigma_t);
    sigma_s_percentage.swap(sigma_s);
    nu_sigma_f_percentage.swap(nu_sigma_f);
    chi_percentage.swap(chi);
        
    for (unsigned b = 0; b < number_of_benchmarks; ++b)
    {
        const unsigned seed = b;
            
        shuffle(sigma_t.begin(), sigma_t.end(), default_random_engine(seed));
        shuffle(sigma_s.begin(), sigma_s.end(), default_random_engine(seed));
        shuffle(nu_sigma_f.begin(), nu_sigma_f.end(), default_random_engine(seed));
        shuffle(chi.begin(), chi.end(), default_random_engine(seed));
            
        lumped_linear_discontinuous(psi_edge_temp);

        for (unsigned i = 0; i < (number_of_cells + 1) * number_of_groups * number_of_ordinates; ++i)
        {
            psi_edge_benchmark_total[i] = (psi_edge_temp[i] + psi_edge_benchmark_total[i] * b) / (b + 1);
        }
    }

    sigma_t_percentage.swap(sigma_t);
    sigma_s_percentage.swap(sigma_s);
    nu_sigma_f_percentage.swap(nu_sigma_f);
    chi_percentage.swap(chi);
}

void Sn_Stochastic::
run_exponential_benchmark(vector<double> &psi_edge_benchmark,
                          vector<double> &psi_edge_benchmark_total,
                          unsigned &number_of_benchmarks)
{
    vector<double> psi_edge((number_of_cells + 1) * number_of_groups * number_of_ordinates, 0);
    vector<double> sigma_t_chord(number_of_cells * number_of_groups, 0);
    vector<double> sigma_s_chord(number_of_cells * number_of_groups * number_of_groups, 0);
    vector<double> nu_sigma_f_chord(number_of_cells * number_of_groups, 0);
    vector<double> chi_chord(number_of_cells * number_of_groups, 0);
    
    for (unsigned b = 0; b < number_of_benchmarks; ++b)
    {
        const unsigned seed = b;
        
        get_randomized_data(sigma_t_chord,
                            sigma_s_chord,
                            nu_sigma_f_chord,
                            chi_chord);

        sigma_t_chord.swap(sigma_t);
        sigma_s_chord.swap(sigma_s);
        nu_sigma_f_chord.swap(nu_sigma_f);
        chi_chord.swap(chi);
        
        shuffle(sigma_t.begin(), sigma_t.end(), default_random_engine(seed));
        shuffle(sigma_s.begin(), sigma_s.end(), default_random_engine(seed));
        shuffle(nu_sigma_f.begin(), nu_sigma_f.end(), default_random_engine(seed));
        shuffle(chi.begin(), chi.end(), default_random_engine(seed));
        
        lumped_linear_discontinuous(psi_edge);

        sigma_t_chord.swap(sigma_t);
        sigma_s_chord.swap(sigma_s);
        nu_sigma_f_chord.swap(nu_sigma_f);
        chi_chord.swap(chi);
        
        for (unsigned i = 0; i < (number_of_cells + 1) * number_of_groups * number_of_ordinates; ++i)
        {
            psi_edge_benchmark_total[i] = (psi_edge[i] + psi_edge_benchmark_total[i] * b) / (b + 1);
        }
    }
}

void Sn_Stochastic::
run_chord_benchmark(vector<double> &psi_edge_benchmark,
                    vector<double> &psi_edge_benchmark_total,
                    unsigned &number_of_benchmarks)
{
    vector<double> psi_edge((number_of_cells + 1) * number_of_groups * number_of_ordinates, 0);
    vector<double> sigma_t_chord(number_of_cells * number_of_groups, 0);
    vector<double> sigma_s_chord(number_of_cells * number_of_groups * number_of_groups, 0);
    vector<double> nu_sigma_f_chord(number_of_cells * number_of_groups, 0);
    vector<double> chi_chord(number_of_cells * number_of_groups, 0);
    
    for (unsigned b = 0; b < number_of_benchmarks; ++b)
    {
        get_randomized_data(sigma_t_chord,
                            sigma_s_chord,
                            nu_sigma_f_chord,
                            chi_chord);

        sigma_t_chord.swap(sigma_t);
        sigma_s_chord.swap(sigma_s);
        nu_sigma_f_chord.swap(nu_sigma_f);
        chi_chord.swap(chi);
        
        if (b % 2 == 0)
        {
            reverse(sigma_t.begin(), sigma_t.end());
            reverse(sigma_s.begin(), sigma_s.end());
            reverse(nu_sigma_f.begin(), nu_sigma_f.end());
            reverse(chi.begin(), chi.end());
        }
        
        lumped_linear_discontinuous(psi_edge);

        sigma_t_chord.swap(sigma_t);
        sigma_s_chord.swap(sigma_s);
        nu_sigma_f_chord.swap(nu_sigma_f);
        chi_chord.swap(chi);
        
        for (unsigned i = 0; i < (number_of_cells + 1) * number_of_groups * number_of_ordinates; ++i)
        {
            psi_edge_benchmark_total[i] = (psi_edge[i] + psi_edge_benchmark_total[i] * b) / (b + 1);
        }
    }
}

void Sn_Stochastic::
get_randomized_data(vector<double> &sigma_t_chord,
                    vector<double> &sigma_s_chord,
                    vector<double> &nu_sigma_f_chord,
                    vector<double> &chi_chord)
{
    unsigned current_cell = 0;
    unsigned current_material = number_of_materials; //
    unsigned end_cell = 0;
    
    while (current_cell < number_of_cells)
    {
        get_randomized_slab(current_material,
                            current_cell,
                            end_cell);
        
        for (unsigned i = current_cell; i < end_cell; ++i)
        {
            for (unsigned g = 0; g < number_of_groups; ++g)
            {
                unsigned k1 = g + number_of_groups * i;
                unsigned k2 = g + number_of_groups * (i + number_of_cells * current_material);
                    
                sigma_t_chord[k1] = sigma_t[k2];
                nu_sigma_f_chord[k1] = nu_sigma_f[k2];
                chi_chord[k1] = chi[k2];

                for (unsigned g1 = 0; g1 < number_of_groups; ++g1)
                {
                    unsigned k3 = g + number_of_groups * (g1 + number_of_groups * i);
                    unsigned k4 = g + number_of_groups * (g1 + number_of_groups * (i + number_of_cells * current_material));;
                        
                    sigma_s_chord[k3] = sigma_s[k4];
                }

            }
        }

        current_cell = end_cell;
    }
}

void Sn_Stochastic::
get_randomized_slab(unsigned &current_material,
                    unsigned &current_cell,
                    unsigned &end_cell)
{
    get_randomized_material(current_material);
    
    double rate_of_occurence = 1 / chord_length[current_material];
    exponential_distribution<double> distribution(rate_of_occurence);

    double slab_length = distribution(generator);

    double sum = 0;
    for (unsigned i = current_cell; i < number_of_cells; ++i)
    {
        sum += cell_length[i];

        if (slab_length < sum || i == number_of_cells -1)
        {
            end_cell = i + 1;
            break;
        }
    }
}

void Sn_Stochastic::
get_randomized_material(unsigned &current_material)
{
    uniform_real_distribution<double> distribution(0.0, 1.0);
    double random_0_1 = distribution(generator);

    double sum = 0.0;
    
    for (unsigned m = 0; m < number_of_materials; ++m)
    {
        sum += transition_probability[m];

        if (random_0_1 < sum)
        {
            if (m != current_material)
            {
                current_material = m;
                break;
            }
            else
            {
                get_randomized_material(current_material);
                break;
            }
        }
    }
}

void Sn_Stochastic::
run_atomic_mix(vector<double> &psi_edge_benchmark,
               vector<double> &psi_edge_benchmark_total)
{
    vector<double> sigma_t_percentage(number_of_cells * number_of_groups, 0.0);
    vector<double> sigma_s_percentage(number_of_cells * number_of_groups * number_of_groups, 0.0);
    vector<double> nu_sigma_f_percentage(number_of_cells * number_of_groups, 0.0);
    vector<double> chi_percentage(number_of_cells * number_of_groups, 0.0);

    for (unsigned i = 0; i < number_of_cells; ++i)
    {
        for (unsigned g = 0; g < number_of_groups; ++g)
        {
            for (unsigned m = 0; m < number_of_materials; ++m)
            {
                unsigned k1 = g + number_of_groups * i;
                unsigned k2 = g + number_of_groups * (i + number_of_cells * m);
                    
                sigma_t_percentage[k1] += sigma_t[k2] * transition_probability[m];
                nu_sigma_f_percentage[k1] += nu_sigma_f[k2] * transition_probability[m];
                chi_percentage[k1] += chi[k2] * transition_probability[m];

                for (unsigned g1 = 0; g1 < number_of_groups; ++g1)
                {
                    unsigned k3 = g + number_of_groups * (g1 + number_of_groups * i);
                    unsigned k4 = g + number_of_groups * (g1 + number_of_groups * (i + number_of_cells * m));
                        
                    sigma_s_percentage[k3] += sigma_s[k4] * transition_probability[m];
                }
            }
        }
    }

    sigma_t_percentage.swap(sigma_t);
    sigma_s_percentage.swap(sigma_s);
    nu_sigma_f_percentage.swap(nu_sigma_f);
    chi_percentage.swap(chi);
            
    lumped_linear_discontinuous(psi_edge_benchmark_total);

    sigma_t_percentage.swap(sigma_t);
    sigma_s_percentage.swap(sigma_s);
    nu_sigma_f_percentage.swap(nu_sigma_f);
    chi_percentage.swap(chi);
}

void Sn_Stochastic::
run_levermore_pomraning(vector<double> &psi_edge,
                        vector<double> &psi_edge_total)
{
    using namespace std;
        
    // temporary variables
    vector<double> phi (number_of_cells * number_of_groups * number_of_nodes, 0); // average scalar flux
    vector<double> phi_old (number_of_cells * number_of_groups * number_of_nodes, 0); // average scalar flux from previous iteration
    vector<double> q (number_of_materials * number_of_cells * number_of_ordinates * number_of_groups * number_of_nodes, 0); // total source, including fission and scattering
    vector<double> psi_nodal (number_of_materials * number_of_cells * number_of_groups * number_of_ordinates * number_of_nodes, 0); // angular flux, left and right
    vector<double> psi_boundary_sources (number_of_groups * number_of_ordinates, 0);
    vector<double> error_phi(number_of_cells * number_of_groups * number_of_nodes, 1);
    vector<double> error_phi_old(number_of_cells * number_of_groups * number_of_nodes, 1);
    
    // make initial guess for psi into a nodal quantity
    for (unsigned m = 0; m < number_of_materials; ++m)
    {
        for (unsigned i = 0; i < number_of_cells; ++i)
        {
            for (unsigned o = 0; o < number_of_ordinates; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    for (unsigned n = 0; n < number_of_nodes; ++n)
                    {
                        unsigned  k1 = n + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
                        unsigned  k2 = g + number_of_groups * (o + number_of_ordinates * ((i+n) + (number_of_cells + 1) * m));
				
                        psi_nodal[k1] = psi_edge[k2];
                    }
                }
            }
        }
    }
    
    // begin iterations
    for (unsigned it = 0; it < max_iterations; ++it)
    {
        // calculate the source
        for (unsigned m = 0; m < number_of_materials; ++m)
        {
            for (unsigned i = 0; i < number_of_cells; ++i)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    for (unsigned n = 0; n < number_of_nodes; ++n)
                    {
                        double sum = 0;
                        for (unsigned g2 = 0; g2 < number_of_groups; ++g2)
                        {
                            unsigned  k1 = g2 + number_of_groups * (i + number_of_cells * m);
                            unsigned  k2 = g2 + number_of_groups * (g + number_of_groups * (i + number_of_cells * m));
                            unsigned  k3 = n + number_of_nodes * (g2 + number_of_groups * i);
                            unsigned  k4 = g + number_of_groups * (i + number_of_cells * m);
                                
                            sum += (chi[k4] * nu_sigma_f[k1] + sigma_s[k2]) * phi[k3];
                        }
                        
                        for (unsigned o = 0; o < number_of_ordinates; ++o)
                        {
                            unsigned  k1 = n + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
                            unsigned  k2 = g + number_of_groups * i;
                            
                            q[k1] = (internal_source[k2] + sum) / 2 * transition_probability[m];
                        }
                    }
                }
            }
        }
/*
        // add in stochastic contribution to source
        for (unsigned m = 0; m < number_of_materials; ++m)
        {
            for (unsigned i = 0; i < number_of_cells; ++i)
            {
                for (unsigned o = 0; o < number_of_ordinates; ++o)
                {
                    for (unsigned g = 0; g < number_of_groups; ++g)
                    {
                        for (unsigned n = 0; n < number_of_nodes; ++n)
                        {
                            unsigned  k1 = n + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
                            for (unsigned m1 = 0; m1 < number_of_materials; ++m1)
                            {
                                if (m1 != m)
                                {
                                    double sum = 0;
                                    for (unsigned m2 = 0; m2 < number_of_materials; ++m2)
                                    {
                                        if (m2 != m1)
                                        {
                                            sum += chord_length[m2];
                                        }
                                    }
                                    
                                    unsigned  k2 = n + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m1)));
                                   
                                    q[k1] += psi_nodal[k2] / chord_length[m1] * chord_length[m] / sum;
                                }
                            }
                        }
                    }
                }
            }
        }
*/
        // boundary condition, x=0
        if (boundary_conditions[0] == "reflected")
        {
            for (unsigned o = 0; o < number_of_ordinates / 2; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    double sum = 0;
                    for (unsigned m = 0; m < number_of_materials; ++m)
                    {
                        unsigned k1 = 0 + number_of_nodes * (g + number_of_groups * ((number_of_ordinates - 1 - o) + number_of_ordinates * (0 + number_of_cells * m)));

                        sum += psi_nodal[k1];
                    }
                    unsigned k1 = g + number_of_groups * o;

                    psi_boundary_sources[k1] = sum;
                }
            }
        }
        else if (boundary_conditions[0] == "vacuum")
        {
            for (unsigned o = 0; o < number_of_ordinates / 2; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    unsigned k1 = g + number_of_groups * o;
                                        
                    psi_boundary_sources[k1] = 0;
                }
            }
        }
        
        // sweep first cell
        for (unsigned  m = 0; m < number_of_materials; ++m)
        {
            for (unsigned  o = 0; o < number_of_ordinates / 2; ++o)
            {
                for (unsigned  g = 0; g < number_of_groups; ++g)
                {
                    unsigned  i = 0;
                    unsigned  k1 = g + number_of_groups * (i + number_of_cells * m);
                    unsigned  k2 = g + number_of_groups * o;
                    unsigned  k4 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));

                    double a1 = ordinates[o] / 2 +  cell_length[i] * (sigma_t[k1] /*+ 1 / chord_length[m]*/) / 2;
                    double a2 = ordinates[o] / 2;
                    double a3 = -ordinates[o] / 2;
                    double a4 = ordinates[o] / 2 + cell_length[i] * (sigma_t[k1] /*+ 1 / chord_length[m]*/) / 2;
                    double s1 = cell_length[i] * (q[k4] / 2) + ordinates[o] *  (boundary_sources[k2] + psi_boundary_sources[k2]) * transition_probability[m];
                    double s2 = cell_length[i] * (q[k4+1] / 2);
		
                    psi_nodal[k4] = (a4 * s1 - a2 * s2) / (a1 * a4 - a2 * a3);
                    psi_nodal[k4+1] = (a3 * s1 - a1 * s2) / (a2 * a3 - a1 * a4);
                }
            }
        }

        // sweep right over cells
        for (unsigned  m = 0; m < number_of_materials; ++m)
        {
            for (unsigned  i = 1; i < number_of_cells; ++i)
            {
                for (unsigned  o = 0; o < number_of_ordinates / 2; ++o)
                {
                    for (unsigned  g = 0; g < number_of_groups; ++g)
                    {
                        unsigned  k1 = g + number_of_groups * (i + number_of_cells * m);
                        unsigned  k4 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
                        unsigned  k5 = 1 + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * ((i-1) + number_of_cells * m)));
		    
                        double a1 = ordinates[o] / 2 + cell_length[i] * (sigma_t[k1]/* + 1 / chord_length[m]*/) / 2;
                        double a2 = ordinates[o] / 2;
                        double a3 = -ordinates[o] / 2;
                        double a4 = ordinates[o] / 2 + cell_length[i] * (sigma_t[k1]/* + 1 / chord_length[m]*/) / 2;
                        double s1 = cell_length[i] * (q[k4] / 2) + ordinates[o] * psi_nodal[k5];
                        double s2 = cell_length[i] * (q[k4+1] / 2);
				
                        psi_nodal[k4] = (a4 * s1 - a2 * s2) / (a1 * a4 - a2 * a3);
                        psi_nodal[k4+1] = (a3 * s1 - a1 * s2) / (a2 * a3 - a1 * a4);
                    }
                }
            }
        }

        // boundary condition, x=X
        if (boundary_conditions[1] == "reflected")
        {
            for (unsigned o = number_of_ordinates / 2; o < number_of_ordinates; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    double sum = 0;
                    for (unsigned m = 0; m < number_of_materials; ++m)
                    {
                        unsigned k1 = 1 + number_of_nodes * (g + number_of_groups * ((number_of_ordinates - 1 - o) + number_of_ordinates * ((number_of_cells - 1) + number_of_cells * m)));

                        sum += psi_nodal[k1];
                    }
                    unsigned k1 = g + number_of_groups * o;

                    psi_boundary_sources[k1] = sum;
                }
            }
        }
        else if (boundary_conditions[1] == "vacuum")
        {
            for (unsigned o = number_of_ordinates / 2; o < number_of_ordinates; ++o)
            {
                for (unsigned g = 0; g < number_of_groups; ++g)
                {
                    unsigned k1 = g + number_of_groups * o;
                                        
                    psi_boundary_sources[k1] = 0;
                }
            }
        }
   
        // sweep final cell
        for (unsigned  m = 0; m < number_of_materials; ++m)
        {
            for (unsigned  o = number_of_ordinates / 2; o < number_of_ordinates; ++o)
            {
                for (unsigned  g = 0; g < number_of_groups; ++g)
                {
                    unsigned  i = number_of_cells - 1;
                    unsigned  k1 = g + number_of_groups * (i + number_of_cells * m);
                    unsigned  k2 = g + number_of_groups * o;
                    unsigned  k4 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));

                    double a1 = -ordinates[o] / 2 + cell_length[i] * (sigma_t[k1]/* + 1 / chord_length[m]*/) / 2;
                    double a2 = ordinates[o] / 2;
                    double a3 = -ordinates[o] / 2;
                    double a4 = -ordinates[o] / 2 + cell_length[i] * (sigma_t[k1]/* + 1 / chord_length[m]*/) / 2;
                    double s1 = cell_length[i] * (q[k4] / 2);
                    double s2 = cell_length[i] * (q[k4+1] / 2) - ordinates[o] * (boundary_sources[k2] + psi_boundary_sources[k2]) * transition_probability[m];
				
                    psi_nodal[k4] = (a4 * s1 - a2 * s2) / (a1 * a4 - a2 * a3);
                    psi_nodal[k4+1] = (a3 * s1 - a1 * s2) / (a2 * a3 - a1 * a4);		
                }
            }
        }
        
        // sweep left over cells
        for (unsigned  m = 0; m < number_of_materials; ++m)
        {
            for (int  i = number_of_cells - 2; i >= 0; --i)
            {
                for (unsigned  o = number_of_ordinates / 2; o < number_of_ordinates; ++o)
                {
                    for (unsigned  g = 0; g < number_of_groups; ++g)
                    {
                        unsigned  k1 = g + number_of_groups * (i + number_of_cells * m);
                        unsigned  k4 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
                        unsigned  k5 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * ((i+1) + number_of_cells * m)));
		    
                        double a1 = -ordinates[o] / 2 + cell_length[i] * (sigma_t[k1]/* + 1 / chord_length[m]*/) / 2;
                        double a2 = ordinates[o] / 2;
                        double a3 = -ordinates[o] / 2;
                        double a4 = -ordinates[o] / 2 + cell_length[i] * (sigma_t[k1]/* + 1 / chord_length[m]*/) / 2;
                        double s1 = cell_length[i] * (q[k4] / 2);
                        double s2 = cell_length[i] * (q[k4+1] / 2) - ordinates[o] * psi_nodal[k5];
				
                        psi_nodal[k5] = (a4 * s1 - a2 * s2) / (a1 * a4 - a2 * a3);
                        psi_nodal[k5+1] = (a3 * s1 - a1 * s2) / (a2 * a3 - a1 * a4);		
                    }
                }
            }
        }

        // calculate new scalar flux
        phi_old = phi;
        for (unsigned  i = 0; i < number_of_cells; ++i)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                for (unsigned  n = 0; n < number_of_nodes; ++n)
                {
                    double sum = 0;
		
                    for (unsigned  o = 0; o < number_of_ordinates; ++o)
                    {
                        for (unsigned  m = 0; m < number_of_materials; ++m)
                        {
                            unsigned  k1 = n + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
			
                            sum += weights[o] * psi_nodal[k1];
                        }
                    }
                    unsigned  k1 = n + number_of_nodes * (g + number_of_groups * i);
		
                    phi[k1] = sum;
                }
            }
        }
        // check for convergence
        bool converged = true;
        error_phi_old = error_phi;
    
        for (unsigned  i = 0; i < number_of_cells; ++i)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                for (unsigned  n = 0; n < number_of_nodes; ++n)
                {
                    unsigned  k1 = n + number_of_nodes * (g + number_of_groups * i);
                    error_phi[k1] = abs(phi[k1] - phi_old[k1]) / phi[k1];
                    if (error_phi[k1] > tolerance * (1 - error_phi[k1] / error_phi_old[k1]))
                    {
                        converged = false;
                        break;
                    }
                }
                if (!converged)
                {
                    break;
                }
            }
            if (!converged)
            {
                break;
            }
        }
        if (converged)
        {
            // cout << "Iterations to converge: " << it << endl;
            break;
        }
        else if (it==max_iterations-1)
        {
            // cout << "Did not converge" << endl;
        }
    }

    for (unsigned  m = 0; m < number_of_materials; ++m)
    {
        //assign left edge flux
        for (unsigned  o = 0; o < number_of_ordinates; ++o)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                unsigned  i = 0;
                unsigned  k1 = g + number_of_groups * (o + number_of_ordinates * (i + (number_of_cells + 1) * m));
                unsigned  k2 = number_of_nodes * (g + number_of_groups * (o +number_of_ordinates * (i + number_of_cells * m))); // n=0
		
                psi_edge[k1] = psi_nodal[k2];
            }
        }

        // calculate edge fluxes
        for (unsigned  i = 1; i < number_of_cells; ++i)
        {
            for (unsigned  o = 0; o < number_of_ordinates; ++o)
            {
                for (unsigned  g = 0; g < number_of_groups; ++g)
                {
                    unsigned  k1 = g + number_of_groups * (o +number_of_ordinates * (i + (number_of_cells + 1) * m));
                    unsigned  k2 = number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * (i + number_of_cells * m)));
                    unsigned  k3 = 1 + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * ((i - 1) + number_of_cells * m))); // n=1
	    
                    psi_edge[k1] = (psi_nodal[k2] + psi_nodal[k3]) / 2; 
                }
            }
        }

        // assign right edge flux
        for (unsigned  o = 0; o < number_of_ordinates; ++o)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                unsigned  i = number_of_cells;
                unsigned  k1 = g + number_of_groups * (o + number_of_ordinates * (i + (number_of_cells + 1) * m));
                unsigned  k2 = 1 + number_of_nodes * (g + number_of_groups * (o + number_of_ordinates * ((i - 1) + number_of_cells * m)));
	    
                psi_edge[k1] = psi_nodal[k2];
            }
        }
    }

    // assign total edge flux
    for (unsigned  i = 0; i < number_of_cells + 1; ++i)
    {
        for (unsigned  o = 0; o < number_of_ordinates; ++o)
        {
            for (unsigned  g = 0; g < number_of_groups; ++g)
            {
                double sum = 0;
	    
                for (unsigned  m = 0; m < number_of_materials; ++m)
                {
                    unsigned  k1 = g + number_of_groups * (o + number_of_ordinates * (i + (number_of_cells + 1) * m));

                    sum += psi_edge[k1];
                }
	    
                unsigned  k1 = g + number_of_groups * (o + number_of_ordinates * i);
	    
                psi_edge_total[k1] = sum;
            }
        }
    }
}

void Sn_Stochastic::
calculate_stochastic_leakage(vector<double> &psi_edge,
                             vector<double> &reflection,
                             vector<double> &transmission)
{
    for (unsigned m = 0; m < number_of_materials; ++m)
    {
        unsigned il = 0;
        unsigned ir = number_of_cells;

        reflection.assign(reflection.size(), 0.0);
        transmission.assign(transmission.size(), 0.0);
        
        for (unsigned op = 0; op < number_of_ordinates / 2; ++op)
        {
            unsigned on = number_of_ordinates - op;
            for (unsigned g = 0; g < number_of_groups; ++g)
            {
                unsigned klr = g + number_of_groups * (op + number_of_ordinates * (il + number_of_cells * m));
                unsigned klt = g + number_of_groups * (on + number_of_ordinates * (il + number_of_cells * m));
                unsigned krt = g + number_of_groups * (op + number_of_ordinates * (ir + number_of_cells * m));
                unsigned krr = g + number_of_groups * (on + number_of_ordinates * (ir + number_of_cells * m));
                
                reflection[0 + 2 * m] += ordinates[op] * weights[op] * psi_edge[klr];
                transmission[0 + 2 * m] += ordinates[on] * weights[on] * psi_edge[klt];
                transmission[1 + 2 * m] += ordinates[op] * weights[op] * psi_edge[krt];
                reflection[1 + 2 * m] += ordinates[on] * weights[on] * psi_edge[krr];
            }
        }
    }
}
